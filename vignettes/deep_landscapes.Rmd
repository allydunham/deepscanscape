---
title: "Analysis Using Deep Landscapes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analysis Using Deep Landscapes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette demonstrates usage of the DeepScanScape package by importing several deep mutational scans and analysing them using the  package.
First we load the DeepScanScape package and initialise a list to hold the parsed datasets.

```{r setup}
library(deepscanscape)
dms <- list()
```

# Loading Deep Mutational Scan Data

We will use the following studies as examples:

* p53 ([Kotler et al. 2018](https://doi.org/10.1016/j.molcel.2018.06.012))
* GFP ([Sarkisyan et al. 2016](https://doi.org/10.1038/nature17995))
* Influenza Nucleoprotein ([Doud et al. 2015](https://doi.org/10.1093/molbev/msv167))
* hYAP65 WW domain ([Araya et al. 2012](https://doi.org/10.1073/pnas.1209751109))

The latter 3 are part of the Deep Landscape dataset generated by [Dunham & Beltrao (2020)](https://doi.org/10.1101/2020.05.26.116756), while the first is a new study not used to generate the landscape.
In each case we first load the data into a base R data frame and examine it's structure, then process it so that it can be loaded into the standard format for DeepScanScape - the deep_mutational_scan object.
These store deep scan data in a standard format and transform variant effect scores onto a standard normalised scale. 

## p53

This data comes from [MaveDB](https://www.mavedb.org), meaning it is in a standardised format and can be directly converted into a deep_mutational_scan.

```{r p53}
df_p53 <- read.csv(system.file("extdata", "urn_mavedb_00000059_a_1_scores.csv", package = "deepscanscape"), skip = 4)
head(df_p53, n = 10)
```

MaveDB data is in a standard format and can easily be converted into a deep mutational scan.
In this case there are duplicate scores and multiply mutated sequences so we use the "duplicates" and "average_multi" arguments.
The scores are already in log<sub>2</sub> form, so do not need further transforming.

```{r p53_dms}
dms$p53 <- deep_mutational_scan(df_p53, name = "Kotler p53", gene = 'p53', study = 'Kotler et al. (2018)',
                                source = "https://www.mavedb.org/scoreset/urn:mavedb:00000059-a-1/",
                                scheme = "mavedb", trans = NULL, na_value = 'impute', duplicates = "mean",
                                average_multi = TRUE)
dms$p53
```

## GFP

## Nucleoprotein

## hYAP65 WW Domain

This study associates each variant effect score (the "fitness" column) with a sequence for the entire WW domain.
It also contains columns giving the mutations, position and mutant amino acid as comma separated strings as well as additional data from which the fitness was calculated.

```{r hyap65}
df_hyap65 <- read.csv(system.file("extdata", "araya_2012_hYAP65_ww.tsv", package = "deepscanscape"), sep = "\t")
head(df_hyap65, n = 10)
```

We will use the "sequence" parsing mode, in addition to demonstrating the position offset argument, since the variants will be naturally numbered within the WW domain.
This requires parsing the input data before passing it to the deep_mutational_scan.
Since the data contains multiple mutations per score scores will be averaged to generate scores for each single mutant where a single mutant is not available.
These averages are not representative when there is an early stop codon, so we will filter all rows containing these before parsing.
The scores already expressed as log<sub>2</sub> enrichment ratios so don't need further transforming.

```{r hyap65_dms}
df_hyap65 <- df_hyap65[grepl("\\*", df_hyap65$sequence), c("sequence", "fitness")]
names(df_hyap65) <- c("sequence", "score")

parsed_df_hyap65 <- parse_deep_scan(df_hyap65, scheme = "sequence", average_multi = TRUE, position_offset = 169)
dms$hyap65 <- deep_mutational_scan(parsed_df_hyap65, name = "hYAP65", gene = "hYAP65", study = "Araya et al. 2012", 
                                   scheme = NULL, trans = NULL)
dms$hyap65
```

# Visulalising and Validating Scans

Once the data has been loaded and parsed we can visualise them and identify potentially unusual properties.
We will primarily focus on the scan of p53.
First we can get an overview of the protein by plotting a heatmap showing all normalised variant effect scores:

```{r heatmap}
plot_er_heatmap(dms$p53)
```
We can also examine the distribution of variant effect scores to check that it matches expectations, including through comparison to the overall distribution in the deep landscape.
It is expected that scores have a bimodal distribution with a peak around 0 comprising neutral variants and a smaller negative peak of deleterious variants.
In this case the new data conforms well to our expectations, suggesting we can meaningfully analyse it using the deep landscape since it contains scores of the same form.

```{r er_distribution}
plot_er_distribution(dms$p53)
```
># TODO Example where distribution is not so good

# Analysis using the Deep Landscape

# Combining Deep Scans

In some cases you may want to analyse multiple scans together, for example if you have several scans of one gene under different conditions or several similar genes in the same condition.
The deep_mutational_scan object supports combined data of this sort, allowing most of the same analyses.
The first stage is combining data from multiple scans into one object:

```{r binding}
combined_scans <- bind_scans(dms)
```

# Re-clustering the Deep Landscape

