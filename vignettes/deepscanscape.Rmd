---
title: "DeepScanScape: Deep Mutational Landscape Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DeepScanScape: Deep Mutational Landscape Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center",
  out.width = "100%",
  out.height = "50%",
  dpi = 300
)
```

This vignette demonstrates usage of the DeepScanScape package by importing several deep mutational scans and analysing them.
First we load the DeepScanScape package and initialise a list to hold the parsed datasets.

```{r setup}
library(deepscanscape)
dms <- list()
```

# Loading Deep Mutational Scan Data

We will use the following studies as examples:

* p53 ([Kotler et al. 2018](https://doi.org/10.1016/j.molcel.2018.06.012))
* UBE2i ([Weile et al. 2017](https://doi.org/10.15252/msb.20177908))
* Influenza Nucleoprotein ([Doud et al. 2015](https://doi.org/10.1093/molbev/msv167))
* hYAP65 WW domain ([Araya et al. 2012](https://doi.org/10.1073/pnas.1209751109))

The latter 3 are part of the Deep Landscape dataset generated by [Dunham & Beltrao (2020)](https://doi.org/10.1101/2020.05.26.116756), while the first is a new study not used to generate the landscape.
In each case we first load the data into a base R data frame and examine it's structure, then process it so that it can be loaded into the standard format for DeepScanScape - the deep_mutational_scan object.
These store deep scan data in a standard format with variant effect scores on a standard normalised scale. 

## p53

This data comes from [MaveDB](https://www.mavedb.org), meaning it is in a standardised format that DeepScanScape recognises and can directly convert into a deep_mutational_scan.

```{r p53}
df_p53 <- read.csv(system.file("extdata", "urn_mavedb_00000059_a_1_scores.csv", package = "deepscanscape"), skip = 4)
head(df_p53, n = 10)
```

In this case there are duplicate scores and multiply mutated sequences so we use the "duplicates" and "average_multi" arguments to handle them.
The scores are already in log<sub>2</sub> form, so do not need any further transforming.

```{r p53_dms}
dms$p53 <- deep_mutational_scan(df_p53, name = "p53", gene = 'p53', study = 'Kotler et al. (2018)',
                                source = "https://www.mavedb.org/scoreset/urn:mavedb:00000059-a-1/",
                                scheme = "mavedb", trans = NULL, na_value = 'impute', duplicates = "mean",
                                average_multi = TRUE)
dms$p53
```

## UBE2i 

This is another dataset from MaveDB, so can be processed in the same way.
However, in this case the data was processed using the VAMP-Seq method ([Matreyek et al. 2018](https://doi.org/10.1038/s41588-018-0122-z)) and scores are on a different scale, with neutral variants $\approx 1$ and null variants $\approx 0$.
DeepScanScape requires scores to be transformed onto the $log_2ER$ scale, including built in transformations for common score formats such as VAMP-Seq.
More unusual scores require a custom function to transform them.

```{r ube2i}
df_ube2i <- read.csv(system.file("extdata", "urn_mavedb_00000001-a-1_scores.csv", package = "deepscanscape"), skip = 4)
dms$ube2i <- deep_mutational_scan(df_ube2i, name = "UBE2i", gene = 'UBE2i', study = 'Weile et al. (2017)',
                                  scheme = "mavedb", trans = "vamp-seq", na_value = 'impute', duplicates = "mean",
                                  average_multi = TRUE)
dms$ube2i
```

## Nucleoprotein

The data from this study is stored in a custom format, with each row representing a position in the protein and columns for the percentage observed in the post selection library for each amino acid.

```{r np}
df_np <- read.delim(file = system.file("extdata", "doud_2015_np.csv", package = "deepscanscape"), sep = " ")
tibble::as_tibble(df_np)
```

This format is similar to the "wide" format supported by DeepScanScape, except scores are not yet normalised against the WT value.
We will therefore normalise each column by the WT score for that row before using the wide parsing mode and $log_2$ transform to create the standard object.

```{r np_dms}
# Set colnames
amino_acids <- c("A", "C", "D", "E", "F", "G", "H", "I", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "W", "Y")
names(df_np) <- c("position", "wt", "entropy", amino_acids)

# Normalise Scores
scores <- as.matrix(df_np[, amino_acids])
wt_score <- scores[matrix(c(1:nrow(scores), match(df_np$wt, amino_acids)), ncol = 2)]
scores <- scores / wt_score
df_np <- cbind(df_np[c("position", "wt")], scores)

# Create deep_mutational_scan
dms$np <- deep_mutational_scan(df_np, name = "NP", gene = "NP", study = "Doud et al. 2015",
                               scheme = "wide", trans = "log2", na_value = "impute")
dms$np
```

## hYAP65 WW Domain

This study associates each variant effect score (the "fitness" column) with a sequence for the entire WW domain - another input format supported by the package.
It also contains columns giving the mutations, position and mutant amino acid as comma separated strings as well as additional data from which the fitness was calculated.

```{r hyap65}
df_hyap65 <- read.csv(system.file("extdata", "araya_2012_hYAP65_ww.tsv", package = "deepscanscape"), sep = "\t")
head(df_hyap65, n = 10)
```

We will use the "sequence" parsing mode, in addition to demonstrating the position offset argument, since the variants would otherwise be numbered within the WW domain.
This argument requires parsing the input data before passing it to deep_mutational_scan with `scheme = NULL`.
Since the data contains multiple mutations per score scores we will be averaged to generate scores for each single mutant where a single mutant is not available.
These averages are not representative when there is an early stop codon, so we will manually filter all rows containing these before parsing.
The scores are expressed as enrichment ratios so only require a $log_2$ transformation.

```{r hyap65_dms}
df_hyap65 <- df_hyap65[!grepl("\\*", df_hyap65$sequence), c("sequence", "fitness")]
names(df_hyap65) <- c("sequence", "score")

parsed_df_hyap65 <- parse_deep_scan(df_hyap65, scheme = "sequence", average_multi = TRUE, position_offset = 169)
dms$hyap65 <- deep_mutational_scan(parsed_df_hyap65, name = "hYAP65", gene = "hYAP65", study = "Araya et al. 2012", 
                                   scheme = NULL, trans = "log2")
dms$hyap65
```

# Visulalising and Validating Scans

Once the data has been loaded and parsed we can visualise them and identify potentially unusual properties.
We will primarily focus on the scan of p53, since that contains data not already incorporated in the landscape.
First, we can get an overview of the protein by plotting a heatmap showing all normalised variant effect scores:

```{r heatmap, fig.width=10, fig.height=8}
plot_er_heatmap(dms$p53)
```
We can also examine the distribution of variant effect scores to check that it matches expectations, including through comparison to the overall distribution in the deep landscape.
It is expected that scores have a bimodal distribution with a peak around 0 comprising neutral variants and a smaller negative peak of deleterious variants.
In this case the new data conforms well to our expectations, suggesting we can meaningfully analyse it using the deep landscape since it contains scores of the same form.

```{r er_distribution, fig.width=10, fig.height=8}
plot_er_distribution(dms$p53)
```

In other cases the score distributions can be more unusual and suggest something unexpected about the study.
For example, NP has a much larger proportion of deleterious variants than usual, potentially suggesting it is a particularly conserved protein.
Similarly the hYAP65 domain doesn't have a clear deleterious peak, suggesting there are not many particularly problematic variants in this region.
Larger deviations, for example a large number of positive scores or a big deviation from the expected peaks can suggest an unusual feature of the experiment or problems with the processing or transformation applied.

```{r er_distribution_unusual, fig.width=10, fig.height=8}
ggpubr::ggarrange(plot_er_distribution(dms$np) + ggplot2::labs(title = "NP"),
                  plot_er_distribution(dms$hyap65) + ggplot2::labs(title = "hYAP65 WW Domain"),
                  nrow = 1, common.legend = TRUE)
```

The package provides some explicit checks to help identify unusual properties.
We can demonstrate this by creating a badly transformed version of our UBE2i scan:

```{r bad_scan, fig.width=10, fig.height=8}
bad_scan <- deep_mutational_scan(df_ube2i, name = "UBE2i", gene = 'UBE2i', study = 'Weile et al. (2017)',
                                  scheme = "mavedb", trans = NULL, na_value = 'impute', duplicates = "mean",
                                  average_multi = TRUE, annotate = TRUE)
plot_er_distribution(bad_scan)
```
The `check_data` function creates a table of potentially unusual properties detected in the dataset.
In this case we identify a generally positive score distribution and positions outside the mapped landscape, both of which can suggest an incorrect transformation (as in this case) or unusual score properties.

```{r check}
check_data(bad_scan, warn = FALSE)
```

# Analysis using the Deep Landscape

Once a standardised deep scan object has been created and checked we can annotate it with information from the deep mutational landscape.
This projects the new positions onto the PCA and UMAP space created from the overall landscape and assigns each position to an amino acid subtype based on the nearest cluster centroid.
The `describe_clusters` function can be used to give information about each position based on the assigned subtype.

```{r annotate}
annotated_dms <- annotate(dms$p53)
head(describe_clusters(annotated_dms), n = 10)
```
We can also visualise the new positions on the annotated deep landscape, for example against the distribution of SIFT4G scores or FoldX $\Delta\Delta G$ predictions.
This plot also allows us to highlight specific positions of interest:

```{r deep_landscape, fig.width=10, fig.height=8}
ggpubr::ggarrange(plot_landscape(annotated_dms, feature = "mean_sift"),
                  plot_landscape(annotated_dms, feature = "total_energy", highlight = c(5, 10, 20)),
                  nrow = 1)
```

These plots can be made for any numerical features of the deep landscape dataset and two special modes, projecting landscape position density and the most prevalent subtype group at that position:

```{r deep_landscape_modes, fig.width=10, fig.height=8}
ggpubr::ggarrange(plot_landscape(annotated_dms, feature = "count"),
                  plot_landscape(annotated_dms, feature = "cluster"),
                  nrow = 1)
```

Finally we can visualise the frequencies of each subtype in the new dataset, with an option to explicitly compare them to the main landscape:

```{r subtype_freqs, fig.width=10, fig.height=8}
plot_cluster_frequencies(annotated_dms)
```

# Combining Deep Scans

In some cases you may want to analyse multiple scans together, for example if you have several scans of one gene under different conditions or several similar genes in the same condition.
The deep_mutational_scan object supports combined data of this sort, allowing the same analyses.
The first stage is combining data from multiple scans into one object, which can be visualised in a similar manner:

```{r binding, fig.width=8, fig.height=15, out.height="80%"}
combined_scans <- bind_scans(dms, annotate_missing = TRUE)
ggpubr::ggarrange(plot_er_heatmap(combined_scans), plot_er_distribution(combined_scans), ncol = 1)
```

Similar deep landscape analyses can also be performed, for example projecting points onto the deep landscape:

```{r combined_deep_landscape, fig.width=10, fig.height=8}
plot_landscape(combined_scans, feature = "cluster")
```

# Re-clustering the Deep Landscape

Finally, the package provides a function to apply the amino acid subtype clustering procedure to new data, including in combination with the original dataset.
This is only likely to be useful when a reasonably large number of additional studies are added and the downstream analysis is more technical so it is only recommended for more advanced users.
Some basic parameters are provided to tweak the clustering procedure but larger changes will require modifying the code and so are also more complicated.
A basic example of re-clustering is shown below, using our example p53 scan that was not already in the dataset:

```{r recluster, fig.width=10, fig.height=8}
reclust <- recluster(dms$p53, add_combined = TRUE)
plot_recluster(reclust)
```
